{"ast":null,"code":"// We don't have access to the autocomplete source when we call `onKeyDown`\n// or `onClick` because those are native browser events.\n// However, we can get the source from the suggestion index.\nfunction getCollectionFromActiveItemId(state) {\n  // Given 3 sources with respectively 1, 2 and 3 suggestions: [1, 2, 3]\n  // We want to get the accumulated counts:\n  // [1, 1 + 2, 1 + 2 + 3] = [1, 3, 3 + 3] = [1, 3, 6]\n  var accumulatedCollectionsCount = state.collections.map(function (collections) {\n    return collections.items.length;\n  }).reduce(function (acc, collectionsCount, index) {\n    var previousValue = acc[index - 1] || 0;\n    var nextValue = previousValue + collectionsCount;\n    acc.push(nextValue);\n    return acc;\n  }, []);\n\n  // Based on the accumulated counts, we can infer the index of the suggestion.\n  var collectionIndex = accumulatedCollectionsCount.reduce(function (acc, current) {\n    if (current <= state.activeItemId) {\n      return acc + 1;\n    }\n    return acc;\n  }, 0);\n  return state.collections[collectionIndex];\n}\n\n/**\n * Gets the highlighted index relative to a suggestion object (not the absolute\n * highlighted index).\n *\n * Example:\n *  [['a', 'b'], ['c', 'd', 'e'], ['f']]\n *                      ↑\n *         (absolute: 3, relative: 1)\n */\nfunction getRelativeActiveItemId(_ref) {\n  var state = _ref.state,\n    collection = _ref.collection;\n  var isOffsetFound = false;\n  var counter = 0;\n  var previousItemsOffset = 0;\n  while (isOffsetFound === false) {\n    var currentCollection = state.collections[counter];\n    if (currentCollection === collection) {\n      isOffsetFound = true;\n      break;\n    }\n    previousItemsOffset += currentCollection.items.length;\n    counter++;\n  }\n  return state.activeItemId - previousItemsOffset;\n}\nexport function getActiveItem(state) {\n  var collection = getCollectionFromActiveItemId(state);\n  if (!collection) {\n    return null;\n  }\n  var item = collection.items[getRelativeActiveItemId({\n    state: state,\n    collection: collection\n  })];\n  var source = collection.source;\n  var itemInputValue = source.getItemInputValue({\n    item: item,\n    state: state\n  });\n  var itemUrl = source.getItemUrl({\n    item: item,\n    state: state\n  });\n  return {\n    item: item,\n    itemInputValue: itemInputValue,\n    itemUrl: itemUrl,\n    source: source\n  };\n}","map":{"version":3,"names":["getCollectionFromActiveItemId","state","accumulatedCollectionsCount","collections","map","items","length","reduce","acc","collectionsCount","index","previousValue","nextValue","push","collectionIndex","current","activeItemId","getRelativeActiveItemId","_ref","collection","isOffsetFound","counter","previousItemsOffset","currentCollection","getActiveItem","item","source","itemInputValue","getItemInputValue","itemUrl","getItemUrl"],"sources":["/Users/zubairahmed/Desktop/ohpolly-zubair/node_modules/@algolia/autocomplete-core/dist/esm/utils/getActiveItem.js"],"sourcesContent":["// We don't have access to the autocomplete source when we call `onKeyDown`\n// or `onClick` because those are native browser events.\n// However, we can get the source from the suggestion index.\nfunction getCollectionFromActiveItemId(state) {\n  // Given 3 sources with respectively 1, 2 and 3 suggestions: [1, 2, 3]\n  // We want to get the accumulated counts:\n  // [1, 1 + 2, 1 + 2 + 3] = [1, 3, 3 + 3] = [1, 3, 6]\n  var accumulatedCollectionsCount = state.collections.map(function (collections) {\n    return collections.items.length;\n  }).reduce(function (acc, collectionsCount, index) {\n    var previousValue = acc[index - 1] || 0;\n    var nextValue = previousValue + collectionsCount;\n    acc.push(nextValue);\n    return acc;\n  }, []);\n\n  // Based on the accumulated counts, we can infer the index of the suggestion.\n  var collectionIndex = accumulatedCollectionsCount.reduce(function (acc, current) {\n    if (current <= state.activeItemId) {\n      return acc + 1;\n    }\n    return acc;\n  }, 0);\n  return state.collections[collectionIndex];\n}\n\n/**\n * Gets the highlighted index relative to a suggestion object (not the absolute\n * highlighted index).\n *\n * Example:\n *  [['a', 'b'], ['c', 'd', 'e'], ['f']]\n *                      ↑\n *         (absolute: 3, relative: 1)\n */\nfunction getRelativeActiveItemId(_ref) {\n  var state = _ref.state,\n    collection = _ref.collection;\n  var isOffsetFound = false;\n  var counter = 0;\n  var previousItemsOffset = 0;\n  while (isOffsetFound === false) {\n    var currentCollection = state.collections[counter];\n    if (currentCollection === collection) {\n      isOffsetFound = true;\n      break;\n    }\n    previousItemsOffset += currentCollection.items.length;\n    counter++;\n  }\n  return state.activeItemId - previousItemsOffset;\n}\nexport function getActiveItem(state) {\n  var collection = getCollectionFromActiveItemId(state);\n  if (!collection) {\n    return null;\n  }\n  var item = collection.items[getRelativeActiveItemId({\n    state: state,\n    collection: collection\n  })];\n  var source = collection.source;\n  var itemInputValue = source.getItemInputValue({\n    item: item,\n    state: state\n  });\n  var itemUrl = source.getItemUrl({\n    item: item,\n    state: state\n  });\n  return {\n    item: item,\n    itemInputValue: itemInputValue,\n    itemUrl: itemUrl,\n    source: source\n  };\n}"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,6BAA6BA,CAACC,KAAK,EAAE;EAC5C;EACA;EACA;EACA,IAAIC,2BAA2B,GAAGD,KAAK,CAACE,WAAW,CAACC,GAAG,CAAC,UAAUD,WAAW,EAAE;IAC7E,OAAOA,WAAW,CAACE,KAAK,CAACC,MAAM;EACjC,CAAC,CAAC,CAACC,MAAM,CAAC,UAAUC,GAAG,EAAEC,gBAAgB,EAAEC,KAAK,EAAE;IAChD,IAAIC,aAAa,GAAGH,GAAG,CAACE,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC;IACvC,IAAIE,SAAS,GAAGD,aAAa,GAAGF,gBAAgB;IAChDD,GAAG,CAACK,IAAI,CAACD,SAAS,CAAC;IACnB,OAAOJ,GAAG;EACZ,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,IAAIM,eAAe,GAAGZ,2BAA2B,CAACK,MAAM,CAAC,UAAUC,GAAG,EAAEO,OAAO,EAAE;IAC/E,IAAIA,OAAO,IAAId,KAAK,CAACe,YAAY,EAAE;MACjC,OAAOR,GAAG,GAAG,CAAC;IAChB;IACA,OAAOA,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC;EACL,OAAOP,KAAK,CAACE,WAAW,CAACW,eAAe,CAAC;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,uBAAuBA,CAACC,IAAI,EAAE;EACrC,IAAIjB,KAAK,GAAGiB,IAAI,CAACjB,KAAK;IACpBkB,UAAU,GAAGD,IAAI,CAACC,UAAU;EAC9B,IAAIC,aAAa,GAAG,KAAK;EACzB,IAAIC,OAAO,GAAG,CAAC;EACf,IAAIC,mBAAmB,GAAG,CAAC;EAC3B,OAAOF,aAAa,KAAK,KAAK,EAAE;IAC9B,IAAIG,iBAAiB,GAAGtB,KAAK,CAACE,WAAW,CAACkB,OAAO,CAAC;IAClD,IAAIE,iBAAiB,KAAKJ,UAAU,EAAE;MACpCC,aAAa,GAAG,IAAI;MACpB;IACF;IACAE,mBAAmB,IAAIC,iBAAiB,CAAClB,KAAK,CAACC,MAAM;IACrDe,OAAO,EAAE;EACX;EACA,OAAOpB,KAAK,CAACe,YAAY,GAAGM,mBAAmB;AACjD;AACA,OAAO,SAASE,aAAaA,CAACvB,KAAK,EAAE;EACnC,IAAIkB,UAAU,GAAGnB,6BAA6B,CAACC,KAAK,CAAC;EACrD,IAAI,CAACkB,UAAU,EAAE;IACf,OAAO,IAAI;EACb;EACA,IAAIM,IAAI,GAAGN,UAAU,CAACd,KAAK,CAACY,uBAAuB,CAAC;IAClDhB,KAAK,EAAEA,KAAK;IACZkB,UAAU,EAAEA;EACd,CAAC,CAAC,CAAC;EACH,IAAIO,MAAM,GAAGP,UAAU,CAACO,MAAM;EAC9B,IAAIC,cAAc,GAAGD,MAAM,CAACE,iBAAiB,CAAC;IAC5CH,IAAI,EAAEA,IAAI;IACVxB,KAAK,EAAEA;EACT,CAAC,CAAC;EACF,IAAI4B,OAAO,GAAGH,MAAM,CAACI,UAAU,CAAC;IAC9BL,IAAI,EAAEA,IAAI;IACVxB,KAAK,EAAEA;EACT,CAAC,CAAC;EACF,OAAO;IACLwB,IAAI,EAAEA,IAAI;IACVE,cAAc,EAAEA,cAAc;IAC9BE,OAAO,EAAEA,OAAO;IAChBH,MAAM,EAAEA;EACV,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}